---
title: KDJ指标
date: 2023-06-16 16:32:06
permalink: /pages/bedd27/
categories:
  - 策略
tags:
  - 
author: 
  name: Mcanjia
  link: https://github.com/mcjisok
---

## 什么是KDJ指标

KDJ指标是一种用于技术分析的指标，由三条线组成，分别为K线、D线和J线。它主要用于判断价格走势的超买和超卖状态，以及价格反转的可能性。

# KDJ指标的计算过程包括以下几个步骤：

* 1、计算未成熟随机值RSV（Raw Stochastic Value）：
RSV = （收盘价 - 最低价） / （最高价 - 最低价） * 100

其中，最低价和最高价是一定周期内的最低价和最高价。

* 2、计算K值（K-line）：
K值 = （2/3） * 前一周期的K值 + （1/3） * 当前周期的RSV

* 3、计算D值（D-line）：
D值 = （2/3） * 前一周期的D值 + （1/3） * 当前周期的K值

* 4、计算J值（J-line）：
J值 = 3 * 当前周期的K值 - 2 * 当前周期的D值

KDJ指标的取值范围通常为0到100之间。常用的参数设置为K值的周期为9，D值的周期为3。

# KDJ指标的应用包括以下几个方面：

* 当K线从下方向上穿过D线并向上运行时，表明价格处于强势状态，可能会继续上涨。
* 当K线从上方向下穿过D线并向下运行时，表明价格处于弱势状态，可能会继续下跌。
* 当KDJ指标的值超过80时，被认为是超买区域，可能意味着价格过高，市场可能出现调整或反转的可能性增加。
* 当KDJ指标的值低于20时，被认为是超卖区域，可能意味着价格过低，市场可能出现反弹或反转的可能性增加。

` KDJ指标常用于股票、期货、外汇等金融市场的技术分析中，它可以辅助分析者判断价格走势的强弱和超买超卖情况，从而指导买卖决策。`

# javascript代码实例

```javascript
interface KDJResult {
  ks?: number[];
  ds?: number[];
  js?: number[];
  k: number;
  d: number;
  j: number;
}
type Tick = number[];
type MaxHighAndMinLow = [number, number];
function getMaxHighAndMinLow(ticks: Tick[]): MaxHighAndMinLow {
  let maxHigh = ticks[0][0];
  let minLow = ticks[0][1];

  for (let i = 0; i < ticks.length; i++) {
    const [high, low] = ticks[i];

    if (high > maxHigh) {
      maxHigh = high;
    }

    if (low < minLow) {
      minLow = low;
    }
  }

  return [maxHigh, minLow];
}

/**
 *
 * 计算kdj指标,rsv的周期为9日
 *
 * @method KDJ
 * @param {Array} ticks
 * 二维数组类型，其中内层数组包含三个元素值，第一个值表示当前Tick的最高价格，第二个表示当前Tick的最低价格，第三个表示当前Tick的收盘价格
 * @return {Object} 返回一个包含k d j属性的对象,每个属性对应的类型为{Array[Number]}
 */
export function calculateKDJ(ticks: Tick[]): KDJResult {
  const nineDaysTicks: Tick[] = [];
  const days = 9;
  const rsvs: number[] = [];

  let ks: number[] = [];
  let ds: number[] = [];
  let js: number[] = [];
  let lastK: number | undefined,
    lastD: number | undefined,
    curK: number,
    curD: number;

  for (let i = 0; i < ticks.length; i++) {
    const t = ticks[i];
    const close = t[2];

    nineDaysTicks.push(t);
    const maxAndMin = getMaxHighAndMinLow(nineDaysTicks);
    const max = maxAndMin[0];
    const min = maxAndMin[1];

    if (max === min) {
      rsvs.push(0);
    } else {
      rsvs.push(((close - min) / (max - min)) * 100);
    }

    if (nineDaysTicks.length === days) {
      nineDaysTicks.shift();
    }

    if (i === 0) {
      lastK = rsvs[i];
      lastD = rsvs[i];
    } else {
      curK = (2 / 3) * (lastK as number) + (1 / 3) * rsvs[i];
      ks.push(curK);

      curD = (2 / 3) * (lastD as number) + (1 / 3) * curK;
      ds.push(curD);

      js.push(3 * curK - 2 * curD);

      lastK = curK;
      lastD = curD;
    }
  }
  return {
    ks: ks,
    ds: ds,
    js: js,
    k: ks[ks.length - 1],
    d: ds[ds.length - 1],
    j: js[js.length - 1]
  };
}
```